"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _subscriber=_interopRequireDefault(require("./subscriber")),_middleware=_interopRequireDefault(require("./middleware")),_async=require("../utils/async"),_queue=_interopRequireDefault(require("../utils/queue"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}const MATCH_ALL_KEY="$all",MATCH_CLOSE_KEY="$closed",NULL_RESULT=Object.freeze({results:null});function resolvePipelineState(a){return a?a.reduce((a,b)=>b?"function"==typeof b?Object.assign(a,b(a)):Object.assign(a,b):a,{}):void 0}class PubChan{constructor(a){this.closed=!1,this.listeners=new Map,this.fnlisteners=new Map,this.subscribers=new Set,this.middleware=a&&(a.find||a.prepare)?new _middleware.default(this,a.find,a.prepare):new _middleware.default(this)}get length(){return this.listeners.size+this.fnlisteners.size}get size(){return this.listeners.size+this.fnlisteners.size}sizeof(...a){let b=0;return 0===a.length?this.listeners.forEach(a=>{b+=a.size}):a.forEach(a=>{const c=this.listeners.get(a);c&&(b+=c.size)}),b}setMiddleware(a,b){this.middleware=new _middleware.default(this,a,b)}emit(...a){if(this.closed)throw new Error("[pubchan]: Tried to emit to a closed pubchan");if(this.pipeline={with:[],ids:new Set,matches:new Set},this.listeners.size){this.middleware.match(a);const b=this.listeners.get(MATCH_ALL_KEY);b&&b.forEach(a=>this.pipeline.matches.add(a))}return this}emitAsync(a,...b){return(0,_async.asynchronously)(()=>this.emit(Array.isArray(a)?a:[a]).send(...b))}with(...a){return a.length&&this.pipeline&&0<this.pipeline.matches.size&&this.pipeline.with.push(...a),this}state(...a){return this.pipeline&&a.length&&(this.pipeline.state=a.reduce((a,b)=>a.concat(b||[]),this.pipeline.state||[])),this}async send(...a){if(this.closed)throw new Error("[pubchan]: Tried to send to a closed pubchan");else if(!this.pipeline.matches.size)return this.pipeline.state?{results:null,state:resolvePipelineState(this.pipeline.state)}:NULL_RESULT;const b={ids:this.pipeline.ids,with:this.pipeline.with,matches:this.pipeline.matches,state:this.pipeline.state&&resolvePipelineState(this.pipeline.state)};a.length&&b.with.push(...a);const c=(0,_queue.default)();b.matches.forEach(a=>a.trigger(b,c));const d={results:await c.promise};return b.state&&(d.state=b.state),d}subscribe(a={}){if(this.closed)throw new Error("[pubchan]: Tried to subscribe to a closed pubchan");const b=new _subscriber.default(this,a);return this.subscribers.add(b),b}async close(...a){if(!this.size)return null;let b;return this.listeners.has(MATCH_CLOSE_KEY)&&(b=await this.emit(MATCH_CLOSE_KEY).with(a).send()),this.closed=!0,this.subscribers.forEach(a=>a.cancel()),b}}var _default=PubChan;exports.default=_default;